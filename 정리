---
겟터 셋터 롬복에 대해 공부하자!

---
Intellij    Ctrl + Alt + l  ->  정리

---
.jar  ->  라이브러리 


this 는 객체가 된 자기 자신을 말한다...  (new가 된 자기 자신)

#if(! static)
객체명.메소드명()  ->  인스턴스 메스도
객체로 실행


#if(static)
클래스명.메소드명() 
클래스 전체 중 한개만 있음 !
객체없이 실행


# 자바의 모든 데이터는 클래스로 가져올 수 있다.....


# 생성자와 메소드는 다르다. 생성자는 new 객체 생성일 때만 실행...




#정적메모리, 힙메모리, 스택메모리

스택 -> 메소드
메소드 안에 메소드를 계속 호출한다 생각하자. 쌓이고 쌓여서 맨 마지막안에 메소드를 리턴 그다음 리턴
그럼 마지막 메소드 리턴 그다음 메소드 리턴~                                                          1000번지
                                                                                            -------------------------
힙 -> 객체                                                                                        1001번지
기아자동차 모닝이란 객체 -> 인스턴스 될 때 정적 메모리는 하나만 할당된다!                         -------------------------   
                                                                                                  1002번지
                                                                                            -------------------------

만약 객체를 여러개 만들었을 경우 공통적인 메소드가 있는경우는 따로 힙메모리에 따로 빼서 하나의 공통 메소드로 사용


정적 안에서 멤버변수를 사용하려면 new 객체를 만든 후 접근 해야됨


변수와 메소드의 시작은 소문자
클래스는 대문자 시작


---

ArrayList : Java 의 1차원적인 배열 컬렉션
배열에 값을 추가 => 길이가 늘어납니다.
배열에 값을 삭제 -> 길이가 감소합니다.
배열의 길이를 알고자 할때는 size() 사용합니다.
ArrayList 는 List 인터페이스를 상속 받은 클래스

[
1. List 부모  ArrayList 자식

List<데이터타입> 변수명 = new ArrayList<>();
ArrayList<데이터타입> 변수명 = new ArrayList<>();

{
List<데이터타입> 변수명 = new ArrayList<>();

부모로 자동 형변형
만약 자식의 기능 10  부모의 기능 5
그럼 이 형태는 5개 밖에 사용 못함..
자식은 부모의 기능을 다 가지고 있음

하지만 객체는 자식으로 만들었기 때문에 메모리에는 15 ( 10 + 5 )개가 숨어져있음
실직적으로 사용할 수 있는거는 부모클래스의 메소드  (..추상화..)

부모클래스 a = new 손자클래스();
((자식클래스)a).   ->   자신 메소드 5개 + 부모 메소드 5개
((손자클래스)a).   ->   자신 메소드 7개 + 부모 메소드 10개 + 할아버지 메소드 5개
}
]


---
<> : Generic (일반화)
제네릭(Generic)이란 타입을 일반화하는 것을 의미합니다. 
'외부에서 지정한다'는 사용자가 제너릭 클래스의 인스턴스를 생성할 때, 
또는 제너릭 메소드를 호출할 때 타입을 정한다는 것을 의미합니다



---

"hong".equals(ID);
상수.equals(변수); 

변수.equals(상수); -> 변수가 null 값이면 Exception 발생할 수 있음 


---
void 메서드 내부의 조건문 안에 return을 사용하는 이유는 특정 조건이 만족될 때 메서드의 실행을 즉시 종료하고 호출자에게 제어를 반환


---
static void main 이 없는 클래스 : 라이브러리


---
pom.xml
메이븐이 라이브러리를 관리한다













221 생성자 선언 
226 생성자 오버로딩
229 하단 this() 자기 생성자 호출 부모 super()
232 리턴타입과 매개변수타입   데이터타입을 맞춰야한다.
231 리턴문장
241 메소드 오버라이딩
243 인스턴스와 this
244 245 247 정적멤버 클래스멤버
250 정적블록 잘 안씀 차라리 정적메소드 정적메소드 기억
255 final 
265 static final
264 접근제한자
271 getter setter ( 책에는 안나와 있지만 롬복을 사용하자)
